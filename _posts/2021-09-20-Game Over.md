<h2>Game Over? Analyzing ESPN's "Win Probability" at 99% and Beyond<h2>

<h3>Introduction</h3>
It's a <a href="https://youtu.be/noLK78Hgq0A?t=4626">play</a> that will live in infamy.<br/><br/>

Down 28-3 with 6:12 remaining in the 3rd quarter of Super Bowl 51, New England Patriots coach Bill Belichick called a desperation trick play on third down. Tom Brady lateraled the ball to wide receiver (and former college quarterback) Julian Edelman, who attempted a 20 yard downfield pass to Dion Lewis. The pass fell, and the odds of the Atlanta Falcons winning the game - according to ESPN's win probability tracker - rose to a staggering 99.7%.  

Unbeknownst to Falcons fans, that was the closest they'd get to victory that day.  

New England proceeded to mount the greatest comeback in Super Bowl history (and one of the <a href="https://slate.com/culture/2017/02/did-the-falcons-really-have-a-99-percent-chance-to-win-the-super-bowl.html"> 4 greatest comebacks in any game in NFL history</a>), ultimately winning 34-28 in overtime.  

And since the question "Who's the greatest quarterback of all time" has been definitively answered, we can ask another question - How much should we trust ESPN's win probability figures - especially at extreme values of 99% or more?  

<h3>Data</h3>
To answer this question, we need to collect the in-game win probabilities and compare them to the final outcome of each game. Fortunately, if you look deep enough in the javascript of ESPN's game summary page for any NFL game* from 2016 and beyond you'll find a variable called "espn.gamepackage.probability.data". This variable maps to a JSON string that contains key data for every play. An extract of a single play's data appears below

<code>espn.gamepackage.probability.data =  <br/>
[{"play":{"period":{"number":1},  <br/>
"homeScore":0,  <br/>
"awayScore":0,  <br/>
"start":{"distance":0,"yardLine":35,"team":{"id":"1"},"down":0,"yardsToEndzone":65}, <br/>
"text":"M.Bosher kicks 65 yards from ATL 35 to end zone, Touchback.",<br/>
"clock":{"displayValue":"15:00"},  <br/>
"type":{"id":"53","text":"Kickoff","abbreviation":"K"}},  <br/>
<b>"homeWinPercentage":0.438,  <br/>
"playId":"40092775239",  </b><br/>
"tiePercentage":0,  <br/>
 "secondsLeft":0},  <br/>
...
</code>

<details>
<summary>Deep Dive: How do I get that data into Python?</summary>  
 Knowing the data above is available in the game summary page's javascript, we can get raw text that looks like JSON-formatted data with everything we need. If we import the javascript text and convert the data above to a JSON object, we can populate a Pandas DataFrame in a few quick steps, leveraging the Pandas <code><a href="https://pandas.pydata.org/pandas-docs/version/1.0.1/reference/api/pandas.json_normalize.html">Pandas.json_normalize</a></code> function.  
 Here's a toy example of the process:  <br/>
 
<code>
import json  <br/>
import pandas  <br/>
my_json_looking_text = '{"name":"John", "age":30, "car":null}'  <br/>
my_json = json.loads(my_json_looking_text)  <br/>
df = pd.json_normalize(my_json)  <br/>
</code>
</details>

So there we have it! A unique play id, the home team win percentage at the moment of the play, and the home and away team scores. That's the raw data we'll need to evaluate how well the win probability forecasts hold up when one team has a 99% or higher win probability. We'll throw out the other interesting bits of data like play types, period, down and distance, etc. They may be useful in another analysis, but won't be needed for our question today. And since we're collecting this for 1,343 NFL games, we'll save a lot of data and memory by only focusing on the most critical data columns.

<h4>Data Cleanup and Processing</h4>
We have the raw data we need (gameId, playId, homeWinPercentage, play.homeScore, and play.AwayScore). But We still need to tease out some other calculated metrics, and remove some of the records. Specifically, we need to:
<ol>
 	<li>Identify the last play of each game, which serves two goals:
<ul>
 	<li>The home/away team scores at the last play of the game tell us the winner!</li>
 	<li>We need to remove the last play of the game from our subsequent analysis, since the "Win Percent" for some team is always 100% when the game is over (excluding ties).</li>
</ul>
</li>
 	<li>Filter out remaining play-by-play records where no team has a 99% or higher win percentage.</li>
</ol>

<h5>Identifying the last play of each game</h5>
After scraping play-by-play data for all NFL games from 2016-2020, we have a dataset of 231,575 individual plays. Each <code>playId</code> value is stored as the 9-digit <code>gameId</code> followed by 2-3 additional, always increasing, digits. Therefore, we can identify the last play of every game as the largest (maximum) <code>playId</code> value for any game.  <br/>

<code>
&#35; df_pbp is a dataframe of all play by play data
<br/>&#35; df_pbp.columns -> (playId, gameId, homeWinPercentage, play.homeScore, play.awayScore)
<br/> df_last_play_each_game = df_pbp.groupby('gameId')['playId'].max()
</code>
 
<br/>
Once we've identified the last play of each game, let's capture the final score in another dataframe. Do this by making a copy of the df_pbp dataframe for rows where the <code>playId</code> is found in the "last play" dataframe.

<code>
 df_game_results = df_pbp[df_pbp['playId'].
    isin(df_last_play_each_game)][['playId', 'gameId', 'play.homeScore',
                                   'play.awayScore']]
</code>

<br/>
And just to be clear, let's rename the "home" and "away" team scores to indicate that they are final:
 
<code>
&#35; Rename scores to indicate "Final"
df_game_results.rename(columns={'play.homeScore': 'homeFinal',
                                'play.awayScore': 'awayFinal'},
                       inplace=True)
</code>

<br/>
 
We want to examine all plays where one team has at least a 99% chance of winning. But the last play of every game shows the winning team with a 100% win probability - we need to now discard these entries from our play-by-play dataset. We'll use a new dataframe, df, as our cleaned up, go-forward play by play dataset.
 
<br/>
<code>
 
 df = df_pbp.loc[~df_pbp['playId'].isin(df_game_results['playId'])]
</code>

<br/>
Now we want to focus only on plays/games where one team has at least a 99% win probability at any point before the game is over.
<br/>
We'll make a calculated column "victory proximity" that measures how close ANY team is to winning the game...
 
<code>
 df['victory_proximity'] = 
 <br/>np.maximum(df['homeWinPercentage'], 1-df['homeWinPercentage'])
</code>

And then we'll throw out any records where this value is under 99%. We'll use a new "df_99" dataframe for this pared-down dataset.

<br/>
<code>
 df_99 = df.loc[df['victory_proximity']>=.99]
</code>

<br/>
Now our <code>df_99</code> dataframe has every (non-final) NFL play where one team has at least a 99% chance of winning, and our <code>df_game_results</code> contains the final score of each game. Let's merge these two together to get the in-game win probability per play alongside the actual, final game results in a single dataframe.  
 
<code>
  df_pbp_full = df_99.merge(df_game_results[['gameId', 'homeFinal', 'awayFinal']],<br/>
                                           how='left', on='gameId',<br/>
                      suffixes=[None, None])
</code>
  
<br/><br/>Hello2!

<h3>Statistical Methods</h3>
